---
title: "Introduction to the Isosceles package"
author:
- name: Michal Kabza
  affiliation:
    - Roche Informatics, F. Hoffmann-La Roche Ltd., Poznań, Poland
  email: michal.kabza@contractors.roche.com
- name: Tim Sterne-Weiler
  affiliation:
    - Department of Oncology Bioinformatics, Genentech Inc., South San Francisco, USA
    - Department of Discovery Oncology, Genentech Inc., South San Francisco, USA
  email: sternewt@gene.com
output:
  BiocStyle::html_document:
    toc_depth: 1
    toc_float: true
package: Isosceles
vignette: >
  %\VignetteIndexEntry{Introduction to the Isosceles package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "##"
)
```

# Introduction 

Isosceles (**Iso**form **S**ingle-**Ce**ll and **L**ong-read **E**xpression 
**S**uite) is an R package dedicated to transcript detection and quantification 
from long reads, supporting both bulk RNA-Seq and scRNA-Seq technologies.

Isosceles can be installed using the following commands:
```r
BiocManager::install(c("scran", "scater", "uwot", "dittoSeq", "ggbio",
                       "BiocStyle"))
devtools::install_github("timbitz/Isosceles", dependencies = TRUE,
                         upgrade = TRUE)
```

Load the Isosceles package:
```{r, message = FALSE}
library(Isosceles)
```

# Input data

Isosceles requires the following input files:

  * BAM file(s) containing aligned long reads
    * We recommend [minimap2](https://github.com/lh3/minimap2) for bulk RNA-Seq data and [Sicelore](https://github.com/ucagenomix/sicelore) for scRNA-Seq data
    * Isosceles requires the BAM file for scRNA-Seq data to contain a tag storing the cell barcode. By default, the tag name for Sicelore ('BC') is assumed, but it can be changed using the *barcode_tag* argument of the `prepare_tcc_se` function
  * FASTA file containing the genomic sequences
  * GTF file containing the genomic annotations
    * Isosceles requires the chromosome names to match between the FASTA file and the GTF file. No automatic conversion between alternative chromosome naming conventions (e.g. '1' and 'chr1') is performed

# Run modes

Isosceles can used in of the following run modes, specified when the `prepare_tcc_se` function is run:

  * **strict** - only annotated reference transcripts will be quantified
  * **de_novo_strict** - de novo transcripts whose all splice sites are known (i.e. found in reference annotations or provided by the user) are also included
  * **de_novo_loose** - de novo transcripts whose all splice sites are reproducibly passing filters in the aligned reads are included as well

# Genome annotations

The appropriate set of transcripts to quantify for the given run mode is selected by Isosceles from the genomic annotations prepared using the `prepare_transcripts` function. The function requires a GTF file containing the reference annotations and (optionally) the transcript structures extracted from the BAM files using the `extract_read_structures` function (necessary for de novo transcript detection).  
There are several important notes regarding the behavior of the `prepare_transcripts` function:

  * While the reference annotations are typically obtained from projects such as Ensembl or GENCODE, Isosceles also accepts merged GTF files containing both reference and de novo detected transcripts from programs such [StringTie](https://ccb.jhu.edu/software/stringtie/) or [IsoQaunt](https://github.com/ablab/IsoQuant). Our benchmarks indicate that using these merged annotations as the reference leads to a much greater sensitivity at discovering new transcripts without a significant increase of the false discovery rate. You can find more details regarding the benchmarks in the Isosceles paper and the [Isosceles_paper](https://github.com/timbitz/Isosceles_paper) repository
  * Isosceles gives all transcripts (reference or de novo detected) new IDs, based on stable hash identifiers, which facilitate ease of matching de novo transcripts across data from the same genome build, regardless of other experimental details
  * Annotated genes and transcripts are merged based on specific criteria, namely:
    * annotated genes sharing introns with each other are merged and given a new ID and symbol, consisting of comma-separated original IDs and symbols
    * annotated transcripts sharing the same intron structure (or, for unspliced transcripts, overlapping on the same strand), as well as having the same transcript start and end bins (default: 50 bp) are merged together and assigned a unique transcript ID

# Isosceles transcript IDs

The Isosceles transcript ID (e.g. 'ISOT-2a9c-c3db-71b4-c3f2:s100628650:e100636850:AP:FL') consists of several parts, separated by colons:

  * Stable hash identifier, starting with the constant 'ISOT' prefix. For spliced transcripts, the identifier contains the first 16 characters of the MD5 hash of transcript's comma-separated intron positions, while for the unspliced transcripts it consists of 12 zeroes and the first 4 characters of the MD5 hash of transcript's chromosome and strand. For convenience, the hash identifier is separated into 4 character segments by dashes
  * The transcript start bin position, prefixed by the 's' character. The default bin size is 50 bp, but it can be changed using the *bin_size* argument of the `prepare_transcripts` function. The start of the bin is always used, ensuring that it's smaller or equal to the transcript start position
  * The transcript end bin position, prefixed by the 'e' character. The default bin size is 50 bp, but it can be changed using the *bin_size* argument of the `prepare_transcripts` function. Unlike the start positions, the end of the bin is always used, ensuring that it's bigger or equal to the transcript end position
  * Splicing compatibility code of the transcript. The full list of these codes can be found in the Isosceles paper, but the following ones are actually used in at least one run mode:
    * AP (Annotated Paths) - reference transcripts
    * EC (Edge Compatible) - de novo transcripts whose all introns are known (i.e. found in reference annotations or provided by the user)
    * NC (Node Compatible) - de novo transcripts whose all splice sites are known
    * DN (De-novo Node) - de novo transcripts whose all splice sites are known or reproducibly passing filters in the aligned reads
  * Truncation status code of the transcript. The full list of these codes can be found in the Isosceles paper, but only the FL (Full-Length) transcripts are used by Isosceles for quantification

# Output

The main output of Isosceles are the SummarizedExperiment objects, which can be created at different resolution levels:

  * **TCC (Transcript Compatibility Counts)** - the most raw form of the data, created directly from the BAM files using the `prepare_tcc_se` function. These values potentially can be used for downstream analysis (e.g. dimensionality reduction for scRNA-Seq datasets), but gene or transcript expression data are used more often for that purpose. Additionally, both the `prepare_pseudobulk_se` function (for summarizing data at pseudo-bulk level) and the `merge_sc_neighbors` function (for merging counts from neighboring cells) use TCC SummarizedExperiment objects as input and produce them as output
  * **transcript** - expression values at the transcript level are obtained using the `prepare_transcript_se` function, utilizing the EM (Expectation–Maximization) algorithm. Normalization using effective transcript lengths is used by default, but should be turned off by setting the *use_length_normalization* argument to FALSE for data generated using a UMI-based protocol (typically for scRNA-Seq datasets). Transcript annotations from the SummarizedExperiment object can be exported to a GTF file using the `export_gtf` function
  * **gene** - expression values at the gene level are obtained using the `prepare_gene_se` function, which is typically very fast, as it doesn't require running the EM algorithm
  * **PSI (Percent Spliced In)** - PSI values are calculated for non-redundant transcriptomic regions of each gene (e.g. transcription start sites or core exons) using the `prepare_psi_se` function, taking a transcript level SummarizedExperiment object as an input

Data in the SummarizedExperiment objects can be accessed using the following commands:

* **assayNames(se)** - assay names available at the given resolution level
* **assay(se, "counts")** - raw count data matrix
* **assay(se, "tpm")** - TPM (Transcripts Per Million) normalized expression value matrix
* **assay(se, "relative_expression")** - relative expression value matrix. All the values are in the 0 to 1 range, and represent the ratios of the TPM values of the analyzed features (e.g. transcripts) and the TPM values of genes they belong to
* **assay(se, "psi")** - PSI (Percent Spliced In) value matrix
* **rowData(se)** - additional data regarding the analyzed features (e.g. transcripts or PSI regions)
* **rowRanges(se)** - a GRangesList object (transcript level data) or a GRanges object (PSI level data) containing the genomic positions of the analyzed features

# Bulk RNA-Seq analysis

## Preparing input data

Get the input file paths for a small bulk RNA-Seq dataset: 
```{r, message = FALSE, warning = FALSE}
bam_file <- system.file(
  "extdata", "SGNex_A549_directRNA_replicate5_run1_chr9_1_1000000.bam",
  package = "Isosceles"
)
gtf_file <- system.file(
  "extdata", "Homo_sapiens.GRCh38.91_chr9_1_1000000.gtf",
  package = "Isosceles"
)
genome_fasta_file <- system.file(
  "extdata", "Homo_sapiens.GRCh38.dna_sm.primary_assembly_chr9_1_1000000.fa",
  package = "Isosceles"
)
```

## Basic Isosceles analysis

Extract read data from the BAM files:
```{r, message = FALSE, warning = FALSE}
bam_files <- c(Sample = bam_file)
bam_parsed <- extract_read_structures(
    bam_files = bam_files
)
```

Prepare transcript data for the analysis:
```{r, message = FALSE, warning = FALSE}
transcript_data <- prepare_transcripts(
    gtf_file = gtf_file,
    genome_fasta_file = genome_fasta_file,
    bam_parsed = bam_parsed,
    min_bam_splice_read_count = 2,
    min_bam_splice_fraction = 0.01
)
```

Create a TCC (Transcript Compatibility Counts) SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_tcc <- prepare_tcc_se(
    bam_files = bam_files,
    transcript_data = transcript_data,
    run_mode = "de_novo_loose",
    min_read_count = 1,
    min_relative_expression = 0
)
se_tcc
```

Create a transcript-level SummarizedExperiment object using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_transcript <- prepare_transcript_se(
    se_tcc = se_tcc,
    use_length_normalization = TRUE
)
se_transcript
```

Create a gene-level SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_gene <- prepare_gene_se(
    se_tcc = se_tcc
)
se_gene
```

# scRNA-Seq analysis

## Preparing input data

Get the input file paths for a small scRNA-Seq dataset: 
```{r, message = FALSE, warning = FALSE}
bam_file <- system.file(
    "extdata", "molecule.tags.GE.bam",
    package = "Isosceles"
)
gtf_file <- system.file(
    "extdata", "chr4.gtf.gz",
    package = "Isosceles"
)
genome_fasta_file <- system.file(
    "extdata", "chr4.fa.gz",
    package = "Isosceles"
)
```

## Basic Isosceles analysis

Extract read data from the BAM files:
```{r, message = FALSE, warning = FALSE}
bam_files <- c(Sample = bam_file)
bam_parsed <- extract_read_structures(
    bam_files = bam_files
)
```

Prepare transcript data for the analysis:
```{r, message = FALSE, warning = FALSE}
transcript_data <- prepare_transcripts(
    gtf_file = gtf_file,
    genome_fasta_file = genome_fasta_file,
    bam_parsed = bam_parsed,
    min_bam_splice_read_count = 1,
    min_bam_splice_fraction = 0.01
)
```

Create a TCC (Transcript Compatibility Counts) SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_tcc <- prepare_tcc_se(
    bam_files = bam_files,
    transcript_data = transcript_data,
    run_mode = "de_novo_loose",
    min_read_count = 1,
    min_relative_expression = 0,
    is_single_cell = TRUE,
    barcode_tag = "BC"
)
se_tcc
```

Create a transcript-level SummarizedExperiment object using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_transcript <- prepare_transcript_se(
    se_tcc = se_tcc,
    use_length_normalization = FALSE
)
se_transcript
```

Create a gene-level SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_gene <- prepare_gene_se(
    se_tcc = se_tcc
)
se_gene
```

## Pseudo-bulk analysis

Create a pseudobulk TCC SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
# Randomly choose one of two labels ('1' or '2') for each cell
set.seed(42)
cell_labels <- sample(1:2, ncol(se_tcc), replace = TRUE)
# Prepare pseudobulk TCC data for given labels
se_pseudobulk_tcc <- prepare_pseudobulk_se(
    se_tcc = se_tcc,
    cell_labels = cell_labels
)
se_pseudobulk_tcc
```

Create a pseudobulk transcript-level SummarizedExperiment object using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_pseudobulk_transcript <- prepare_transcript_se(
    se_tcc = se_pseudobulk_tcc,
    use_length_normalization = FALSE
)
se_pseudobulk_transcript
```

Create a pseudobulk gene-level SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_pseudobulk_gene <- prepare_gene_se(
    se_tcc = se_pseudobulk_tcc
)
se_pseudobulk_gene
```

## Merging neighboring cell data

Isosceles also allows adding counts from neighboring cells to each cell, 
potentially improving the quantification results:
```{r, message = FALSE, warning = FALSE}
# Get PCA coordinates of each cell from transcript expression data
sce_transcript <- methods::as(se_transcript, "SingleCellExperiment")
sce_transcript <- scuttle::computeLibraryFactors(sce_transcript)
sce_transcript <- scuttle::logNormCounts(sce_transcript)
set.seed(42)
sce_transcript <- scater::runPCA(sce_transcript, ncomponents = 2)
pca_mat <- SingleCellExperiment::reducedDim(sce_transcript, "PCA")
# Add TCC values from two nearest cells to each cell
se_merged_tcc <- merge_sc_neighbors(
    se_tcc = se_tcc,
    pca_mat = pca_mat,
    k = 2
)
se_merged_tcc
```

Recalculate transcript expression values from merged data using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_merged_transcript <- prepare_transcript_se(
    se_tcc = se_merged_tcc,
    use_length_normalization = FALSE
)
se_merged_transcript
```

# Downstream analysis

## Preparing input data

Load a transcript-level SummarizedExperiment object containing expression levels 
of 100 highly variable transcripts across 200 cells from a mix of ovarian cancer 
cell lines:
```{r, message = FALSE, warning = FALSE}
se <- readRDS(system.file("extdata", "se_transcript_100_hvts.rds",
                          package = "Isosceles"))
se
```

## Basic scRNA-Seq analysis

Run a basic scRNA-Seq data analysis using Bioconductor packages:
```{r, message = FALSE, warning = FALSE}
sce <- as(se, "SingleCellExperiment")
sce <- scuttle::computeLibraryFactors(sce)
sce <- scuttle::logNormCounts(sce)
dec <- scran::modelGeneVar(sce)
top_hvgs <- scran::getTopHVGs(dec, n = 100)
set.seed(42)
sce <- scran::denoisePCA(sce, technical = dec, subset.row = top_hvgs)
set.seed(42)
sce <- scater::runUMAP(sce, dimred = "PCA")
sce
```

Cell clustering using k-means:
```{r, message = FALSE, warning = FALSE}
set.seed(42)
colLabels(sce) <- bluster::clusterRows(reducedDim(sce, "PCA"),
                                       bluster::KmeansParam(3))
dittoSeq::dittoDimPlot(sce, "label", reduction.use = "UMAP",
                       size = 2, main = "",
                       do.label = TRUE, labels.highlight = TRUE,
                       legend.show = FALSE)
```

## Identifying marker transcripts

Identify marker transcripts for individual clusters:
```{r, message = FALSE, warning = FALSE}
markers <- scran::findMarkers(sce, groups = sce$label, test.type = "t",
                              pval.type = "all", direction = "up")
markers
head(markers[[1]])
```

Get top 3 marker transcripts for each cluster:
```{r, message = FALSE, warning = FALSE}
top_markers <- markers %>%
  lapply(function(x) rownames(x)[1:3]) %>%
  unlist() %>%
  unname()
top_markers
```

Top marker transcript heatmap:
```{r, message = FALSE, warning = FALSE}
dittoSeq::dittoHeatmap(sce, top_markers, annot.by = "label",
                       cluster_rows = TRUE, fontsize_row = 6)
```

## Transcript expression UMAP plots {.tabset}

```{r, message = FALSE, warning = FALSE, results = 'asis'}
for (transcript_id in top_markers) {
    cat("\n\n### ", transcript_id, "\n")
    umap_plot <- dittoSeq::dittoDimPlot(
        sce, transcript_id, size = 2,
        min.color = "#0072B2", max.color = "#F0E442",
        order = "increasing"
    )
    print(umap_plot)
}
```

### {-}

# PSI analysis

## Preparing input data

Load a transcript-level SingleCellExperiment object containing expression levels 
of transcripts of the CAV1 gene across 2,060 cells from a mix of ovarian cancer 
cell lines:
```{r, message = FALSE, warning = FALSE}
sce_transcript <- readRDS(system.file("extdata", "sce_transcript_cav1.rds",
                                      package = "Isosceles"))
sce_transcript
```

## PSI analysis using Isosceles

Create a PSI (Percent Spliced In) SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_psi <- prepare_psi_se(sce_transcript)
se_psi
```

PSI values are calculated for the following types of regions:

  * **TSS** - transcription start sites
  * **TES** - transcription end sites
  * **CE** - core exonic regions
  * **RI** - retained intronic regions
  * **A5** - 5' alternative exonic regions
  * **A3** - 3' alternative exonic regions

## PSI region visualization

PSI value heatmap for the CAV1 gene:
```{r, message = FALSE, warning = FALSE}
# Prepare the PSI values matrix and remove cells with no CAV1 expression
psi_matrix <- as.matrix(t(assay(se_psi, "psi")))
psi_matrix <- psi_matrix[rowSums(psi_matrix) > 0,]
# Prepare the heatmap column annotations data frame
col_anno_df <- rowData(se_psi) %>%
    as.data.frame %>%
    dplyr::transmute(region = factor(
        type, levels = c("TSS", "CE", "RI", "A5", "A3", "TES")
    ))
# Define region colors
region_colors <- c(
    TSS = "#FF83FF", CE = "#FF9289", RI = "#82B7FF",
    A5 = "#00D65C", A3 = "#00DAE0", TES = "#D3BA00"
)
# Plot the PSI value heatmap
pheatmap::pheatmap(
    mat = psi_matrix,
    annotation_col = col_anno_df,
    color = viridis::cividis(100),
    cluster_rows = TRUE, cluster_cols = FALSE,
    show_rownames = FALSE, show_colnames = FALSE,
    treeheight_row = 0, annotation_names_col = FALSE,
    annotation_colors = list(region = region_colors)
)
```

Plot the CAV1 transcript structures:
```{r, message = FALSE, warning = FALSE}
# Calculate the relative expression of transcripts based on overall TPM values
# across all cells
tx_tpm_sums <- rowSums(assay(sce_transcript, "tpm"))
tx_rel_exprs <- tx_tpm_sums / sum(tx_tpm_sums) * 100
# Prepare the GenomicRangesList object for visualization
tx_granges_list <- rowRanges(sce_transcript)
tx_granges_list <- unlist(tx_granges_list)
mcols(tx_granges_list)$plot_type <- "exon"
mcols(tx_granges_list)$rel_expr <- tx_rel_exprs[names(tx_granges_list)]
tx_granges_list <- split(tx_granges_list, names(tx_granges_list))
# Prepare the PSI regions GenomicRanges objects for visualization
region_granges <- rowRanges(se_psi)
bin_region_types <- c("TSS", "TES")
other_region_types <- c("CE", "RI", "A5", "A3")
region_granges_bin <- region_granges[
    mcols(region_granges)$type %in% bin_region_types
]
region_granges_other <- region_granges[
    mcols(region_granges)$type %in% other_region_types
]
mcols(region_granges_bin)$plot_type <- "exon"
mcols(region_granges_other)$plot_type <- "exon"
# Plot the transcript structures and PSI regions
ggbio::tracks(
    `TSS/TES\nsites` = ggbio::autoplot(
        GRanges(region_granges_bin),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.4, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    ggbio::autoplot(
        tx_granges_list,
        ggplot2::aes(type = plot_type, col = rel_expr, fill = rel_expr) 
    ),
    `PSI\nregions` = ggbio::autoplot(
        GRanges(region_granges_other),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.3, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    heights = c(0.1, 0.8, 0.1),
    label.text.cex = 0.7
)
```

Plot the CAV1 transcript structures with introns shrinked to max 1000 bp:
```{r, message = FALSE, warning = FALSE}
# Prepare the shrinkage function
region_granges_list <- GRangesList(PSI = rowRanges(se_psi))
shrink_func <- biovizBase::shrinkageFun(
    IRanges::gaps(unlist(c(tx_granges_list, region_granges_list))),
    max.gap = 1000
)
# Prepare the shrinked GenomicRangesList object for visualization
shrink_granges_list <- S4Vectors::endoapply(tx_granges_list, function(gr) {
  gr <- shrink_func(gr)
  mcols(gr)$.ori <- NULL
  return(gr)
})
# Prepare the shrinked PSI regions GenomicRanges objects for visualization
shrink_granges_bin <- GRanges(shrink_func(region_granges_bin))
mcols(shrink_granges_bin)$.ori <- NULL
shrink_granges_other <- GRanges(shrink_func(region_granges_other))
mcols(shrink_granges_other)$.ori <- NULL
# Plot the transcript structures and PSI regions
ggbio::tracks(
    `TSS/TES\nsites` = ggbio::autoplot(
        GRanges(shrink_granges_bin),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.4, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    ggbio::autoplot(
        shrink_granges_list,
        ggplot2::aes(type = plot_type, col = rel_expr, fill = rel_expr) 
    ),
    `PSI\nregions` = ggbio::autoplot(
        GRanges(shrink_granges_other),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.3, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    heights = c(0.1, 0.8, 0.1),
    label.text.cex = 0.7
)
```

## PSI UMAP plots {.tabset}

```{r, message = FALSE, warning = FALSE, results = 'asis'}
# Calculate UMAP coordinates based on PSI values
sce_psi <- as(se_psi, "SingleCellExperiment")
reducedDim(sce_psi, "UMAP") <- reducedDim(sce_transcript, "UMAP")
sce_psi <- sce_psi[
    , colSums(assay(sce_psi, "psi")) > 0
]
# Create UMAP plots colored by PSI values for each gene region
for (region_id in rownames(sce_psi)) {
    cat("\n\n### ", region_id, "\n")
    umap_plot <- dittoSeq::dittoDimPlot(
        sce_psi, region_id, size = 1,
        min.color = "#0072B2", max.color = "#F0E442",
        order = "increasing"
    )
    print(umap_plot)
}
```

### {-}

# Session Info

```{r}
sessionInfo()
```
