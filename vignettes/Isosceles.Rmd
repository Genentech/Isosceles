---
title: "Introduction to the Isosceles package"
author:
- name: Michal Kabza
  affiliation:
    - Roche Informatics, F. Hoffmann-La Roche Ltd., PoznaÅ„, Poland
  email: michal.kabza@contractors.roche.com
- name: Tim Sterne-Weiler
  affiliation:
    - Department of Oncology Bioinformatics, Genentech Inc., South San Francisco, USA
    - Department of Discovery Oncology, Genentech Inc., South San Francisco, USA
  email: sternewt@gene.com
output:
  BiocStyle::html_document:
    toc_depth: 1
    toc_float: true
package: Isosceles
vignette: >
  %\VignetteIndexEntry{Introduction to the Isosceles package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "##"
)
```

# Introduction 

Isosceles (**Iso**form **S**ingle-**Ce**ll and **L**ong-read **E**xpression 
**S**uite) is an R package dedicated to transcript detection and quantification 
from long reads, supporting both bulk RNA-Seq and scRNA-Seq technologies.

Isosceles can be installed using the following commands:
```r
BiocManager::install(c("scran", "scater", "uwot", "dittoSeq", "ggbio",
                       "BiocStyle"))
devtools::install_github("timbitz/Isosceles", dependencies = TRUE,
                         upgrade = TRUE)
```

Load the Isosceles package:
```{r, message = FALSE}
library(Isosceles)
```

# Input data

Isosceles requires the following input files:

  * BAM file(s) containing aligned long reads
    * We recommend [minimap2](https://github.com/lh3/minimap2) for bulk RNA-Seq data and [Sicelore](https://github.com/ucagenomix/sicelore) for scRNA-Seq data
    * Isosceles requires the BAM file for scRNA-Seq data to contain a tag storing the cell barcode. By default, the tag name for Sicelore ('BC') is assumed, but it can be changed using the *barcode_tag* argument of the `prepare_tcc_se` function
  * FASTA file containing the genomic sequences
  * GTF file containing the genomic annotations
    * Isosceles requires the chromosome names to match between the FASTA file and the GTF file. No automatic conversion between alternative chromosome naming conventions (e.g. '1' and 'chr1') is performed

# Run modes

Isosceles can used in of the following run modes:

  * **strict** - only annotated reference transcripts will be quantified
  * **de_novo_strict** - de novo transcripts whose all splice sites are known (i.e. found in reference annotations or provided by the user) are also included
  * **de_novo_loose** - de novo transcripts whose all splice sites are reproducibly passing filters in the aligned reads are included as well

# Bulk RNA-Seq analysis

## Preparing input data

Get the input file paths for a small bulk RNA-Seq dataset: 
```{r, message = FALSE, warning = FALSE}
bam_file <- system.file(
  "extdata", "SGNex_A549_directRNA_replicate5_run1_chr9_1_1000000.bam",
  package = "Isosceles"
)
gtf_file <- system.file(
  "extdata", "Homo_sapiens.GRCh38.91_chr9_1_1000000.gtf",
  package = "Isosceles"
)
genome_fasta_file <- system.file(
  "extdata", "Homo_sapiens.GRCh38.dna_sm.primary_assembly_chr9_1_1000000.fa",
  package = "Isosceles"
)
```

## Basic Isosceles analysis

Extract read data from the BAM files:
```{r, message = FALSE, warning = FALSE}
bam_files <- c(Sample = bam_file)
bam_parsed <- extract_read_structures(
    bam_files = bam_files
)
```

Prepare transcript data for the analysis:
```{r, message = FALSE, warning = FALSE}
transcript_data <- prepare_transcripts(
    gtf_file = gtf_file,
    genome_fasta_file = genome_fasta_file,
    bam_parsed = bam_parsed,
    min_bam_splice_read_count = 2,
    min_bam_splice_fraction = 0.01
)
```

Create a TCC (Transcript Compatibility Counts) SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_tcc <- prepare_tcc_se(
    bam_files = bam_files,
    transcript_data = transcript_data,
    run_mode = "de_novo_loose",
    min_read_count = 1,
    min_relative_expression = 0
)
se_tcc
```

Create a transcript-level SummarizedExperiment object using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_transcript <- prepare_transcript_se(
    se_tcc = se_tcc,
    use_length_normalization = TRUE
)
se_transcript
```

Create a gene-level SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_gene <- prepare_gene_se(
    se_tcc = se_tcc
)
se_gene
```

# scRNA-Seq analysis

## Preparing input data

Get the input file paths for a small scRNA-Seq dataset: 
```{r, message = FALSE, warning = FALSE}
bam_file <- system.file(
    "extdata", "molecule.tags.GE.bam",
    package = "Isosceles"
)
gtf_file <- system.file(
    "extdata", "chr4.gtf.gz",
    package = "Isosceles"
)
genome_fasta_file <- system.file(
    "extdata", "chr4.fa.gz",
    package = "Isosceles"
)
```

## Basic Isosceles analysis

Extract read data from the BAM files:
```{r, message = FALSE, warning = FALSE}
bam_files <- c(Sample = bam_file)
bam_parsed <- extract_read_structures(
    bam_files = bam_files
)
```

Prepare transcript data for the analysis:
```{r, message = FALSE, warning = FALSE}
transcript_data <- prepare_transcripts(
    gtf_file = gtf_file,
    genome_fasta_file = genome_fasta_file,
    bam_parsed = bam_parsed,
    min_bam_splice_read_count = 1,
    min_bam_splice_fraction = 0.01
)
```

Create a TCC (Transcript Compatibility Counts) SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_tcc <- prepare_tcc_se(
    bam_files = bam_files,
    transcript_data = transcript_data,
    run_mode = "de_novo_loose",
    min_read_count = 1,
    min_relative_expression = 0,
    is_single_cell = TRUE,
    barcode_tag = "BC"
)
se_tcc
```

Create a transcript-level SummarizedExperiment object using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_transcript <- prepare_transcript_se(
    se_tcc = se_tcc,
    use_length_normalization = FALSE
)
se_transcript
```

Create a gene-level SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_gene <- prepare_gene_se(
    se_tcc = se_tcc
)
se_gene
```

## Pseudo-bulk analysis

Create a pseudobulk TCC SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
# Randomly choose one of two labels ('1' or '2') for each cell
set.seed(42)
cell_labels <- sample(1:2, ncol(se_tcc), replace = TRUE)
# Prepare pseudobulk TCC data for given labels
se_pseudobulk_tcc <- prepare_pseudobulk_se(
    se_tcc = se_tcc,
    cell_labels = cell_labels
)
se_pseudobulk_tcc
```

Create a pseudobulk transcript-level SummarizedExperiment object using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_pseudobulk_transcript <- prepare_transcript_se(
    se_tcc = se_pseudobulk_tcc,
    use_length_normalization = FALSE
)
se_pseudobulk_transcript
```

Create a pseudobulk gene-level SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_pseudobulk_gene <- prepare_gene_se(
    se_tcc = se_pseudobulk_tcc
)
se_pseudobulk_gene
```

## Merging neighboring cell data

Isosceles also allows adding counts from neighboring cells to each cell, 
potentially improving the quantification results:
```{r, message = FALSE, warning = FALSE}
# Get PCA coordinates of each cell from transcript expression data
sce_transcript <- methods::as(se_transcript, "SingleCellExperiment")
sce_transcript <- scuttle::computeLibraryFactors(sce_transcript)
sce_transcript <- scuttle::logNormCounts(sce_transcript)
set.seed(42)
sce_transcript <- scater::runPCA(sce_transcript, ncomponents = 2)
pca_mat <- SingleCellExperiment::reducedDim(sce_transcript, "PCA")
# Add TCC values from two nearest cells to each cell
se_merged_tcc <- merge_sc_neighbors(
    se_tcc = se_tcc,
    pca_mat = pca_mat,
    k = 2
)
se_merged_tcc
```

Recalculate transcript expression values from merged data using the EM algorithm:
```{r, message = FALSE, warning = FALSE}
se_merged_transcript <- prepare_transcript_se(
    se_tcc = se_merged_tcc,
    use_length_normalization = FALSE
)
se_merged_transcript
```

# Downstream analysis

## Preparing input data

Load a transcript-level SummarizedExperiment object containing expression levels 
of 100 highly variable transcripts across 200 cells from a mix of ovarian cancer 
cell lines:
```{r, message = FALSE, warning = FALSE}
se <- readRDS(system.file("extdata", "se_transcript_100_hvts.rds",
                          package = "Isosceles"))
se
```

## Basic scRNA-Seq analysis

Run a basic scRNA-Seq data analysis using Bioconductor packages:
```{r, message = FALSE, warning = FALSE}
sce <- as(se, "SingleCellExperiment")
sce <- scuttle::computeLibraryFactors(sce)
sce <- scuttle::logNormCounts(sce)
dec <- scran::modelGeneVar(sce)
top_hvgs <- scran::getTopHVGs(dec, n = 100)
set.seed(42)
sce <- scran::denoisePCA(sce, technical = dec, subset.row = top_hvgs)
set.seed(42)
sce <- scater::runUMAP(sce, dimred = "PCA")
sce
```

Cell clustering using k-means:
```{r, message = FALSE, warning = FALSE}
set.seed(42)
colLabels(sce) <- bluster::clusterRows(reducedDim(sce, "PCA"),
                                       bluster::KmeansParam(3))
dittoSeq::dittoDimPlot(sce, "label", reduction.use = "UMAP",
                       size = 2, main = "",
                       do.label = TRUE, labels.highlight = TRUE,
                       legend.show = FALSE)
```

## Identifying marker transcripts

Identify marker transcripts for individual clusters:
```{r, message = FALSE, warning = FALSE}
markers <- scran::findMarkers(sce, groups = sce$label, test.type = "t",
                              pval.type = "all", direction = "up")
markers
head(markers[[1]])
```

Get top 3 marker transcripts for each cluster:
```{r, message = FALSE, warning = FALSE}
top_markers <- markers %>%
  lapply(function(x) rownames(x)[1:3]) %>%
  unlist() %>%
  unname()
top_markers
```

Top marker transcript heatmap:
```{r, message = FALSE, warning = FALSE}
dittoSeq::dittoHeatmap(sce, top_markers, annot.by = "label",
                       cluster_rows = TRUE, fontsize_row = 6)
```

## Transcript expression UMAP plots {.tabset}

```{r, message = FALSE, warning = FALSE, results = 'asis'}
for (transcript_id in top_markers) {
    cat("\n\n### ", transcript_id, "\n")
    umap_plot <- dittoSeq::dittoDimPlot(
        sce, transcript_id, size = 2,
        min.color = "#0072B2", max.color = "#F0E442",
        order = "increasing"
    )
    print(umap_plot)
}
```

### {-}

# PSI analysis

## Preparing input data

Load a transcript-level SingleCellExperiment object containing expression levels 
of transcripts of the CAV1 gene across 2,060 cells from a mix of ovarian cancer 
cell lines:
```{r, message = FALSE, warning = FALSE}
sce_transcript <- readRDS(system.file("extdata", "sce_transcript_cav1.rds",
                                      package = "Isosceles"))
sce_transcript
```

## PSI analysis using Isosceles

Create a PSI (Percent Spliced In) SummarizedExperiment object:
```{r, message = FALSE, warning = FALSE}
se_psi <- prepare_psi_se(sce_transcript)
se_psi
```

PSI values are calculated for the following types of regions:

  * **TSS** - transcription start sites
  * **TES** - transcription end sites
  * **CE** - core exonic regions
  * **RI** - retained intronic regions
  * **A5** - 5' alternative exonic regions
  * **A3** - 3' alternative exonic regions

## PSI region visualization

PSI value heatmap for the CAV1 gene:
```{r, message = FALSE, warning = FALSE}
# Prepare a PSI values matrix and remove cells with no CAV1 expression
psi_matrix <- as.matrix(t(assay(se_psi, "psi")))
psi_matrix <- psi_matrix[rowSums(psi_matrix) > 0,]
# Prepare a heatmap column annotations data frame
col_anno_df <- rowData(se_psi) %>%
    as.data.frame %>%
    dplyr::transmute(region = factor(
        type, levels = c("TSS", "CE", "RI", "A5", "A3", "TES")
    ))
# Define region colors
region_colors <- c(
    TSS = "#FF83FF", CE = "#FF9289", RI = "#82B7FF",
    A5 = "#00D65C", A3 = "#00DAE0", TES = "#D3BA00"
)
# Plot the PSI value heatmap
pheatmap::pheatmap(
    mat = psi_matrix,
    annotation_col = col_anno_df,
    color = viridis::cividis(100),
    cluster_rows = TRUE, cluster_cols = FALSE,
    show_rownames = FALSE, show_colnames = FALSE,
    treeheight_row = 0, annotation_names_col = FALSE,
    annotation_colors = list(region = region_colors)
)
```

Plot the CAV1 transcript structures:
```{r, message = FALSE, warning = FALSE}
# Calculate the relative expression of transcripts based on overall TPM values
# across all cells
tx_tpm_sums <- rowSums(assay(sce_transcript, "tpm"))
tx_rel_exprs <- tx_tpm_sums / sum(tx_tpm_sums) * 100
# Prepare the GenomicRangesList object for visualization
tx_granges_list <- rowRanges(sce_transcript)
tx_granges_list <- unlist(tx_granges_list)
mcols(tx_granges_list)$plot_type <- "exon"
mcols(tx_granges_list)$rel_expr <- tx_rel_exprs[names(tx_granges_list)]
tx_granges_list <- split(tx_granges_list, names(tx_granges_list))
# Prepare the PSI regions GenomicRanges objects for visualization
region_granges <- rowRanges(se_psi)
bin_region_types <- c("TSS", "TES")
other_region_types <- c("CE", "RI", "A5", "A3")
region_granges_bin <- region_granges[
    mcols(region_granges)$type %in% bin_region_types
]
region_granges_other <- region_granges[
    mcols(region_granges)$type %in% other_region_types
]
mcols(region_granges_bin)$plot_type <- "exon"
mcols(region_granges_other)$plot_type <- "exon"
# Plot the transcript structures and PSI regions
ggbio::tracks(
    `TSS/TES\nsites` = ggbio::autoplot(
        GRanges(region_granges_bin),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.4, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    ggbio::autoplot(
        tx_granges_list,
        ggplot2::aes(type = plot_type, col = rel_expr, fill = rel_expr) 
    ),
    `PSI\nregions` = ggbio::autoplot(
        GRanges(region_granges_other),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.3, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    heights = c(0.1, 0.8, 0.1),
    label.text.cex = 0.7
)
```

Plot the CAV1 transcript structures with introns shrinked to max 1000 bp:
```{r, message = FALSE, warning = FALSE}
# Prepare the shrinkage function
region_granges_list <- GRangesList(PSI = rowRanges(se_psi))
shrink_func <- biovizBase::shrinkageFun(
    IRanges::gaps(unlist(c(tx_granges_list, region_granges_list))),
    max.gap = 1000
)
# Prepare the shrinked GenomicRangesList object for visualization
shrink_granges_list <- S4Vectors::endoapply(tx_granges_list, function(gr) {
  gr <- shrink_func(gr)
  mcols(gr)$.ori <- NULL
  return(gr)
})
# Prepare the shrinked PSI regions GenomicRanges objects for visualization
shrink_granges_bin <- GRanges(shrink_func(region_granges_bin))
mcols(shrink_granges_bin)$.ori <- NULL
shrink_granges_other <- GRanges(shrink_func(region_granges_other))
mcols(shrink_granges_other)$.ori <- NULL
# Plot the transcript structures and PSI regions
ggbio::tracks(
    `TSS/TES\nsites` = ggbio::autoplot(
        GRanges(shrink_granges_bin),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[bin_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.4, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    ggbio::autoplot(
        shrink_granges_list,
        ggplot2::aes(type = plot_type, col = rel_expr, fill = rel_expr) 
    ),
    `PSI\nregions` = ggbio::autoplot(
        GRanges(shrink_granges_other),
        ggplot2::aes(type = plot_type, col = type, fill = type)
    ) +
        ggplot2::scale_fill_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::scale_colour_manual(
            values = region_colors[other_region_types]
        ) +
        ggplot2::theme(
            legend.key.size = ggplot2::unit(0.3, 'cm'),
            legend.title = ggplot2:::element_blank()
        ),
    heights = c(0.1, 0.8, 0.1),
    label.text.cex = 0.7
)
```

## PSI UMAP plots {.tabset}

```{r, message = FALSE, warning = FALSE, results = 'asis'}
# Calculate UMAP coordinates based on PSI values
sce_psi <- as(se_psi, "SingleCellExperiment")
reducedDim(sce_psi, "UMAP") <- reducedDim(sce_transcript, "UMAP")
sce_psi <- sce_psi[
    , colSums(assay(sce_psi, "psi")) > 0
]
# Create UMAP plots colored by PSI values for each gene region
for (region_id in rownames(sce_psi)) {
    cat("\n\n### ", region_id, "\n")
    umap_plot <- dittoSeq::dittoDimPlot(
        sce_psi, region_id, size = 1,
        min.color = "#0072B2", max.color = "#F0E442",
        order = "increasing"
    )
    print(umap_plot)
}
```

### {-}

# Session Info

```{r}
sessionInfo()
```
